# 进程

## 创建进程的两种方式

## fork：

* fork可以创建当前进程的一个副本，父进程和子进程只有PID不同，在该系统调用执行之后，系统中有两个进程，都执行同样的操作，父进程内存中的内容被复制，至少从程序的角度来看是这样的，linux通过写时复制的技术使得fork操作更加的高效，主要的原理是将内存复制操作延迟到父进程或者子进程向某个内存页面写入数据之前，在只读反问的情况下父进程和子进程可以共用一个内存页。

## exec：

* exec是将一个新程序加载到当前进程的内存中并执行，旧程序的内存页将刷出，其内容将替为新数据，然后开始执行新程序

## 1.线程

> 进程并不是内核支持的唯一一种程序执行的形式，除了重量级别进程之外，还有一种形式是线程（有时也成为轻量级进程），例如在浏览器需要并行加载若干的图像时，通常浏览器只好执行几次fork和exec调用，这些进程只是负责加载图像，并使用某种通信机制将接收的数据提供给主程序，在使用线程时，这种情况更容易处理一些，浏览器定义了一个例程来加载图像，可以将例程作为线程启动，使用参数不同的多个线程即可，由于线程和主程序共享同样的地址空间，主程序自动就可以反问到接收到的数据，除了防止线程反问同一内存去区而采取的互斥机制外，就不需要通信了。
>
> linux用clone方法创建线程，其工作方式类似于fork，但是启用了精确的检测，已确认哪些资源与父进程共享，哪些资源为线程独立创建

## 2.地址空间

> 由于内存区域是通过指针寻址，因此对cpu的字长决定了所能管理的地址空间的最大长度，地址空间的最大长度和实际可用的物理内存数量无关，因此被称为虚拟地址空间，**Linux将虚拟地址空间划分为内核空间和用户空间。**

这种划分与可用的内存数量无关，由于地址空间虚拟化的结果，每个用户进程都认为自身有3g内存，各个系统进程的用户空间是完全彼此分离的，

## 3.虚拟和物理地址空间

![](/assets/import.png)

上图中进程A的虚拟内存页1映射到物理内存页4，而进程B的虚拟内存1映射到物理内存页5，因此可以知道不同进程的同一虚拟地址具有不同的含义。

#### 3.1页面交换与页面回收

> 页面交换通过利用磁盘空间作为拓展内存/从而增大可用的内存，在内核需要更多的内存时不需要经常使用的页可以写入硬盘，如果在需要访问相同的数据时候，内存会调用相应的页切换回内存，通过缺页异常机制，

#### 3.2系统调用

#### 3.3缓存

> 内核使用缓存改进系统性能，从低速的快设备读取的数据会缓存在内存中，即使数据在当时已经不再需要了，在应用程序下一次反问该数据的时候，它可以从较快素的的内存中读取，因而绕过了低速的块设备，由于内核是通过基于页的内存映射来实现访问快设备的，因此缓存也是按页组织的，也就是整页都缓存了，故而称为页缓存。

# 进程管理和调度





