# 进程管理和调度

> 内核和处理器建立了多任务的错觉，既可以并行做几种操作

进程的状态：

* 运行：该进程此可正在执行
* 等待：进程能够运行，但是没有得到应许，因为cpu分配给另一个进程，调度器可以在下一次任务切换时选择该进程
* 睡眠： 进程正在睡眠无法运行，因为它在等待一个外部事件，调度器无法在下一次任务切换时选择该进程

![](/assets/1533568505%281%29.png)

```
对于一个排队中的可运行的进程，我们可以考察其中可能的状态转化，该进程已经就绪 ，但是没有运行，因为CPU分配给了其他including，在分配CPU时间之后，其状态改变为“运行”

在调度器决定从该进程收回CPU资源时，过程状态从运行改变为等待，循环重新开始，实际上根据是否可以被信号中断，有两种“睡眠”状态。

如果进程必须等待事件，则其状态从运行改变为睡眠，但是进程状态无法从睡眠直接转化为运行，在所等待的事件发生后，进程先变回“等待”状态，然后重新回到正常状态。
```

上文中没有列出一个特殊的进程状态“僵尸进程”，进程已经死了，但是仍然以某种方式活着，实际上，说这些进程死了，是因为其资源已经释放，因此他们无法也绝不会再次运行，说他们仍然活着，是因为进程表中仍然有对应的表项。

僵尸进程是如何产生的，其原因在于linux系统下进程创建和销毁的方式，在两种事件发生时，程序将终止运行，第一，程序必须由另一个进程或者一个用户杀死\(sigterm或者sigkill\)信号来完成，进程的父进程在子进程终止时必须调用或者已经调用wait4系统调用，这相当于向内核证实父进程已经确认子进程的终结，因为残余的数据在内核中占据的空间极少，所有这几乎不是一个问题。

只有在第一个条件发生（程序终止）而第二个条件不成立的情况下才会出现僵尸进程，在进程终止后，其数据尚未从进程表删除之前，进程总是暂时处于僵尸进程，有时候（例如，父进程编程极其糟糕，没有发生wait调用），僵尸进程可能稳定地寄生于进程表中，直到下一次系统重启，从进程工具（ps\|top）的输出，可以看到僵尸进程。

